(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./LDrawLoader.js":
/*!************************!*\
  !*** ./LDrawLoader.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("THREE.LDrawLoader = function () {\n  var conditionalLineVertShader =\n  /* glsl */\n  `\n\tattribute vec3 control0;\n\tattribute vec3 control1;\n\tattribute vec3 direction;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_vertex>\n\t#include <fog_pars_vertex>\n\t#include <logdepthbuf_pars_vertex>\n\t#include <clipping_planes_pars_vertex>\n\tvoid main() {\n\t\t#include <color_vertex>\n\n\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\t\tgl_Position = projectionMatrix * mvPosition;\n\n\t\t// Transform the line segment ends and control points into camera clip space\n\t\tvec4 c0 = projectionMatrix * modelViewMatrix * vec4( control0, 1.0 );\n\t\tvec4 c1 = projectionMatrix * modelViewMatrix * vec4( control1, 1.0 );\n\t\tvec4 p0 = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\tvec4 p1 = projectionMatrix * modelViewMatrix * vec4( position + direction, 1.0 );\n\n\t\tc0.xy /= c0.w;\n\t\tc1.xy /= c1.w;\n\t\tp0.xy /= p0.w;\n\t\tp1.xy /= p1.w;\n\n\t\t// Get the direction of the segment and an orthogonal vector\n\t\tvec2 dir = p1.xy - p0.xy;\n\t\tvec2 norm = vec2( -dir.y, dir.x );\n\n\t\t// Get control point directions from the line\n\t\tvec2 c0dir = c0.xy - p1.xy;\n\t\tvec2 c1dir = c1.xy - p1.xy;\n\n\t\t// If the vectors to the controls points are pointed in different directions away\n\t\t// from the line segment then the line should not be drawn.\n\t\tfloat d0 = dot( normalize( norm ), normalize( c0dir ) );\n\t\tfloat d1 = dot( normalize( norm ), normalize( c1dir ) );\n\t\tdiscardFlag = float( sign( d0 ) != sign( d1 ) );\n\n\t\t#include <logdepthbuf_vertex>\n\t\t#include <clipping_planes_vertex>\n\t\t#include <fog_vertex>\n\t}\n\t`;\n  var conditionalLineFragShader =\n  /* glsl */\n  `\n\tuniform vec3 diffuse;\n\tuniform float opacity;\n\tvarying float discardFlag;\n\n\t#include <common>\n\t#include <color_pars_fragment>\n\t#include <fog_pars_fragment>\n\t#include <logdepthbuf_pars_fragment>\n\t#include <clipping_planes_pars_fragment>\n\tvoid main() {\n\n\t\tif ( discardFlag > 0.5 ) discard;\n\n\t\t#include <clipping_planes_fragment>\n\t\tvec3 outgoingLight = vec3( 0.0 );\n\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t\t#include <logdepthbuf_fragment>\n\t\t#include <color_fragment>\n\t\toutgoingLight = diffuseColor.rgb; // simple shader\n\t\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t\t#include <tonemapping_fragment>\n\t\t#include <encodings_fragment>\n\t\t#include <fog_fragment>\n\t\t#include <premultiplied_alpha_fragment>\n\t}\n\t`;\n  var tempVec0 = new THREE.Vector3();\n  var tempVec1 = new THREE.Vector3();\n\n  function smoothNormals(triangles, lineSegments) {\n    function hashVertex(v) {\n      // NOTE: 1e2 is pretty coarse but was chosen because it allows edges\n      // to be smoothed as expected (see minifig arms). The errors between edges\n      // could be due to matrix multiplication.\n      var x = ~~(v.x * 1e2);\n      var y = ~~(v.y * 1e2);\n      var z = ~~(v.z * 1e2);\n      return `${x},${y},${z}`;\n    }\n\n    function hashEdge(v0, v1) {\n      return `${hashVertex(v0)}_${hashVertex(v1)}`;\n    }\n\n    var hardEdges = new Set();\n    var halfEdgeList = {};\n    var fullHalfEdgeList = {};\n    var normals = []; // Save the list of hard edges by hash\n\n    for (var i = 0, l = lineSegments.length; i < l; i++) {\n      var ls = lineSegments[i];\n      var v0 = ls.v0;\n      var v1 = ls.v1;\n      hardEdges.add(hashEdge(v0, v1));\n      hardEdges.add(hashEdge(v1, v0));\n    } // track the half edges associated with each triangle\n\n\n    for (var i = 0, l = triangles.length; i < l; i++) {\n      var tri = triangles[i];\n\n      for (var i2 = 0, l2 = 3; i2 < l2; i2++) {\n        var index = i2;\n        var next = (i2 + 1) % 3;\n        var v0 = tri[`v${index}`];\n        var v1 = tri[`v${next}`];\n        var hash = hashEdge(v0, v1); // don't add the triangle if the edge is supposed to be hard\n\n        if (hardEdges.has(hash)) continue;\n        halfEdgeList[hash] = tri;\n        fullHalfEdgeList[hash] = tri;\n      }\n    } // NOTE: Some of the normals wind up being skewed in an unexpected way because\n    // quads provide more \"influence\" to some vertex normals than a triangle due to\n    // the fact that a quad is made up of two triangles and all triangles are weighted\n    // equally. To fix this quads could be tracked separately so their vertex normals\n    // are weighted appropriately or we could try only adding a normal direction\n    // once per normal.\n    // Iterate until we've tried to connect all triangles to share normals\n\n\n    while (true) {\n      // Stop if there are no more triangles left\n      var halfEdges = Object.keys(halfEdgeList);\n      if (halfEdges.length === 0) break; // Exhaustively find all connected triangles\n\n      var i = 0;\n      var queue = [fullHalfEdgeList[halfEdges[0]]];\n\n      while (i < queue.length) {\n        // initialize all vertex normals in this triangle\n        var tri = queue[i];\n        i++;\n        var faceNormal = tri.faceNormal;\n\n        if (tri.n0 === null) {\n          tri.n0 = faceNormal.clone();\n          normals.push(tri.n0);\n        }\n\n        if (tri.n1 === null) {\n          tri.n1 = faceNormal.clone();\n          normals.push(tri.n1);\n        }\n\n        if (tri.n2 === null) {\n          tri.n2 = faceNormal.clone();\n          normals.push(tri.n2);\n        } // Check if any edge is connected to another triangle edge\n\n\n        for (var i2 = 0, l2 = 3; i2 < l2; i2++) {\n          var index = i2;\n          var next = (i2 + 1) % 3;\n          var v0 = tri[`v${index}`];\n          var v1 = tri[`v${next}`]; // delete this triangle from the list so it won't be found again\n\n          var hash = hashEdge(v0, v1);\n          delete halfEdgeList[hash];\n          var reverseHash = hashEdge(v1, v0);\n          var otherTri = fullHalfEdgeList[reverseHash];\n\n          if (otherTri) {\n            // NOTE: If the angle between triangles is > 67.5 degrees then assume it's\n            // hard edge. There are some cases where the line segments do not line up exactly\n            // with or span multiple triangle edges (see Lunar Vehicle wheels).\n            if (Math.abs(otherTri.faceNormal.dot(tri.faceNormal)) < 0.25) {\n              continue;\n            } // if this triangle has already been traversed then it won't be in\n            // the halfEdgeList. If it has not then add it to the queue and delete\n            // it so it won't be found again.\n\n\n            if (reverseHash in halfEdgeList) {\n              queue.push(otherTri);\n              delete halfEdgeList[reverseHash];\n            } // Find the matching edge in this triangle and copy the normal vector over\n\n\n            for (var i3 = 0, l3 = 3; i3 < l3; i3++) {\n              var otherIndex = i3;\n              var otherNext = (i3 + 1) % 3;\n              var otherV0 = otherTri[`v${otherIndex}`];\n              var otherV1 = otherTri[`v${otherNext}`];\n              var otherHash = hashEdge(otherV0, otherV1);\n\n              if (otherHash === reverseHash) {\n                if (otherTri[`n${otherIndex}`] === null) {\n                  var norm = tri[`n${next}`];\n                  otherTri[`n${otherIndex}`] = norm;\n                  norm.add(otherTri.faceNormal);\n                }\n\n                if (otherTri[`n${otherNext}`] === null) {\n                  var norm = tri[`n${index}`];\n                  otherTri[`n${otherNext}`] = norm;\n                  norm.add(otherTri.faceNormal);\n                }\n\n                break;\n              }\n            }\n          }\n        }\n      }\n    } // The normals of each face have been added up so now we average them by normalizing the vector.\n\n\n    for (var i = 0, l = normals.length; i < l; i++) {\n      normals[i].normalize();\n    }\n  }\n\n  function isPrimitiveType(type) {\n    return /primitive/i.test(type) || type === 'Subpart';\n  }\n\n  function LineParser(line, lineNumber) {\n    this.line = line;\n    this.lineLength = line.length;\n    this.currentCharIndex = 0;\n    this.currentChar = ' ';\n    this.lineNumber = lineNumber;\n  }\n\n  LineParser.prototype = {\n    constructor: LineParser,\n    seekNonSpace: function () {\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar !== ' ' && this.currentChar !== '\\t') {\n          return;\n        }\n\n        this.currentCharIndex++;\n      }\n    },\n    getToken: function () {\n      var pos0 = this.currentCharIndex++; // Seek space\n\n      while (this.currentCharIndex < this.lineLength) {\n        this.currentChar = this.line.charAt(this.currentCharIndex);\n\n        if (this.currentChar === ' ' || this.currentChar === '\\t') {\n          break;\n        }\n\n        this.currentCharIndex++;\n      }\n\n      var pos1 = this.currentCharIndex;\n      this.seekNonSpace();\n      return this.line.substring(pos0, pos1);\n    },\n    getRemainingString: function () {\n      return this.line.substring(this.currentCharIndex, this.lineLength);\n    },\n    isAtTheEnd: function () {\n      return this.currentCharIndex >= this.lineLength;\n    },\n    setToEnd: function () {\n      this.currentCharIndex = this.lineLength;\n    },\n    getLineNumberString: function () {\n      return this.lineNumber >= 0 ? \" at line \" + this.lineNumber : \"\";\n    }\n  };\n\n  function sortByMaterial(a, b) {\n    if (a.colourCode === b.colourCode) {\n      return 0;\n    }\n\n    if (a.colourCode < b.colourCode) {\n      return -1;\n    }\n\n    return 1;\n  }\n\n  function createObject(elements, elementSize, isConditionalSegments) {\n    // Creates a THREE.LineSegments (elementSize = 2) or a THREE.Mesh (elementSize = 3 )\n    // With per face / segment material, implemented with mesh groups and materials array\n    // Sort the triangles or line segments by colour code to make later the mesh groups\n    elements.sort(sortByMaterial);\n    var positions = [];\n    var normals = [];\n    var materials = [];\n    var bufferGeometry = new THREE.BufferGeometry();\n    var prevMaterial = null;\n    var index0 = 0;\n    var numGroupVerts = 0;\n\n    for (var iElem = 0, nElem = elements.length; iElem < nElem; iElem++) {\n      var elem = elements[iElem];\n      var v0 = elem.v0;\n      var v1 = elem.v1; // Note that LDraw coordinate system is rotated 180 deg. in the X axis w.r.t. Three.js's one\n\n      positions.push(v0.x, v0.y, v0.z, v1.x, v1.y, v1.z);\n\n      if (elementSize === 3) {\n        positions.push(elem.v2.x, elem.v2.y, elem.v2.z);\n        var n0 = elem.n0 || elem.faceNormal;\n        var n1 = elem.n1 || elem.faceNormal;\n        var n2 = elem.n2 || elem.faceNormal;\n        normals.push(n0.x, n0.y, n0.z);\n        normals.push(n1.x, n1.y, n1.z);\n        normals.push(n2.x, n2.y, n2.z);\n      }\n\n      if (prevMaterial !== elem.material) {\n        if (prevMaterial !== null) {\n          bufferGeometry.addGroup(index0, numGroupVerts, materials.length - 1);\n        }\n\n        materials.push(elem.material);\n        prevMaterial = elem.material;\n        index0 = iElem * elementSize;\n        numGroupVerts = elementSize;\n      } else {\n        numGroupVerts += elementSize;\n      }\n    }\n\n    if (numGroupVerts > 0) {\n      bufferGeometry.addGroup(index0, Infinity, materials.length - 1);\n    }\n\n    bufferGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));\n\n    if (elementSize === 3) {\n      bufferGeometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));\n    }\n\n    var object3d = null;\n\n    if (elementSize === 2) {\n      object3d = new THREE.LineSegments(bufferGeometry, materials);\n    } else if (elementSize === 3) {\n      object3d = new THREE.Mesh(bufferGeometry, materials);\n    }\n\n    if (isConditionalSegments) {\n      object3d.isConditionalLine = true;\n      var controlArray0 = new Float32Array(elements.length * 3 * 2);\n      var controlArray1 = new Float32Array(elements.length * 3 * 2);\n      var directionArray = new Float32Array(elements.length * 3 * 2);\n\n      for (var i = 0, l = elements.length; i < l; i++) {\n        var os = elements[i];\n        var c0 = os.c0;\n        var c1 = os.c1;\n        var v0 = os.v0;\n        var v1 = os.v1;\n        var index = i * 3 * 2;\n        controlArray0[index + 0] = c0.x;\n        controlArray0[index + 1] = c0.y;\n        controlArray0[index + 2] = c0.z;\n        controlArray0[index + 3] = c0.x;\n        controlArray0[index + 4] = c0.y;\n        controlArray0[index + 5] = c0.z;\n        controlArray1[index + 0] = c1.x;\n        controlArray1[index + 1] = c1.y;\n        controlArray1[index + 2] = c1.z;\n        controlArray1[index + 3] = c1.x;\n        controlArray1[index + 4] = c1.y;\n        controlArray1[index + 5] = c1.z;\n        directionArray[index + 0] = v1.x - v0.x;\n        directionArray[index + 1] = v1.y - v0.y;\n        directionArray[index + 2] = v1.z - v0.z;\n        directionArray[index + 3] = v1.x - v0.x;\n        directionArray[index + 4] = v1.y - v0.y;\n        directionArray[index + 5] = v1.z - v0.z;\n      }\n\n      bufferGeometry.setAttribute('control0', new THREE.BufferAttribute(controlArray0, 3, false));\n      bufferGeometry.setAttribute('control1', new THREE.BufferAttribute(controlArray1, 3, false));\n      bufferGeometry.setAttribute('direction', new THREE.BufferAttribute(directionArray, 3, false));\n    }\n\n    return object3d;\n  } //\n\n\n  function LDrawLoader(manager) {\n    THREE.Loader.call(this, manager); // This is a stack of 'parse scopes' with one level per subobject loaded file.\n    // Each level contains a material lib and also other runtime variables passed between parent and child subobjects\n    // When searching for a material code, the stack is read from top of the stack to bottom\n    // Each material library is an object map keyed by colour codes.\n\n    this.parseScopesStack = null; // Array of THREE.Material\n\n    this.materials = []; // Not using THREE.Cache here because it returns the previous HTML error response instead of calling onError()\n    // This also allows to handle the embedded text files (\"0 FILE\" lines)\n\n    this.subobjectCache = {}; // This object is a map from file names to paths. It agilizes the paths search. If it is not set then files will be searched by trial and error.\n\n    this.fileMap = null; // Add default main triangle and line edge materials (used in piecess that can be coloured with a main color)\n\n    this.setMaterials([this.parseColourMetaDirective(new LineParser(\"Main_Colour CODE 16 VALUE #FF8080 EDGE #333333\")), this.parseColourMetaDirective(new LineParser(\"Edge_Colour CODE 24 VALUE #A0A0A0 EDGE #333333\"))]); // If this flag is set to true, each subobject will be a THREE.Object.\n    // If not (the default), only one object which contains all the merged primitives will be created.\n\n    this.separateObjects = false; // If this flag is set to true the vertex normals will be smoothed.\n\n    this.smoothNormals = true;\n  } // Special surface finish tag types.\n  // Note: \"MATERIAL\" tag (e.g. GLITTER, SPECKLE) is not implemented\n\n\n  LDrawLoader.FINISH_TYPE_DEFAULT = 0;\n  LDrawLoader.FINISH_TYPE_CHROME = 1;\n  LDrawLoader.FINISH_TYPE_PEARLESCENT = 2;\n  LDrawLoader.FINISH_TYPE_RUBBER = 3;\n  LDrawLoader.FINISH_TYPE_MATTE_METALLIC = 4;\n  LDrawLoader.FINISH_TYPE_METAL = 5; // State machine to search a subobject path.\n  // The LDraw standard establishes these various possible subfolders.\n\n  LDrawLoader.FILE_LOCATION_AS_IS = 0;\n  LDrawLoader.FILE_LOCATION_TRY_PARTS = 1;\n  LDrawLoader.FILE_LOCATION_TRY_P = 2;\n  LDrawLoader.FILE_LOCATION_TRY_MODELS = 3;\n  LDrawLoader.FILE_LOCATION_TRY_RELATIVE = 4;\n  LDrawLoader.FILE_LOCATION_TRY_ABSOLUTE = 5;\n  LDrawLoader.FILE_LOCATION_NOT_FOUND = 6;\n  LDrawLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {\n    constructor: LDrawLoader,\n    load: function (url, onLoad, onProgress, onError) {\n      if (!this.fileMap) {\n        this.fileMap = {};\n      }\n\n      var scope = this;\n      var fileLoader = new THREE.FileLoader(this.manager);\n      fileLoader.setPath(this.path);\n      fileLoader.setRequestHeader(this.requestHeader);\n      fileLoader.setWithCredentials(this.withCredentials);\n      fileLoader.load(url, function (text) {\n        scope.processObject(text, onLoad, null, url);\n      }, onProgress, onError);\n    },\n    parse: function (text, path, onLoad) {\n      // Async parse.  This function calls onParse with the parsed THREE.Object3D as parameter\n      this.processObject(text, onLoad, null, path);\n    },\n    setMaterials: function (materials) {\n      // Clears parse scopes stack, adds new scope with material library\n      this.parseScopesStack = [];\n      this.newParseScopeLevel(materials);\n      this.getCurrentParseScope().isFromParse = false;\n      this.materials = materials;\n      return this;\n    },\n    setFileMap: function (fileMap) {\n      this.fileMap = fileMap;\n      return this;\n    },\n    newParseScopeLevel: function (materials) {\n      // Adds a new scope level, assign materials to it and returns it\n      var matLib = {};\n\n      if (materials) {\n        for (var i = 0, n = materials.length; i < n; i++) {\n          var material = materials[i];\n          matLib[material.userData.code] = material;\n        }\n      }\n\n      var topParseScope = this.getCurrentParseScope();\n      var newParseScope = {\n        lib: matLib,\n        url: null,\n        // Subobjects\n        subobjects: null,\n        numSubobjects: 0,\n        subobjectIndex: 0,\n        inverted: false,\n        category: null,\n        keywords: null,\n        // Current subobject\n        currentFileName: null,\n        mainColourCode: topParseScope ? topParseScope.mainColourCode : '16',\n        mainEdgeColourCode: topParseScope ? topParseScope.mainEdgeColourCode : '24',\n        currentMatrix: new THREE.Matrix4(),\n        matrix: new THREE.Matrix4(),\n        // If false, it is a root material scope previous to parse\n        isFromParse: true,\n        triangles: null,\n        lineSegments: null,\n        conditionalSegments: null,\n        // If true, this object is the start of a construction step\n        startingConstructionStep: false\n      };\n      this.parseScopesStack.push(newParseScope);\n      return newParseScope;\n    },\n    removeScopeLevel: function () {\n      this.parseScopesStack.pop();\n      return this;\n    },\n    addMaterial: function (material) {\n      // Adds a material to the material library which is on top of the parse scopes stack. And also to the materials array\n      var matLib = this.getCurrentParseScope().lib;\n\n      if (!matLib[material.userData.code]) {\n        this.materials.push(material);\n      }\n\n      matLib[material.userData.code] = material;\n      return this;\n    },\n    getMaterial: function (colourCode) {\n      // Given a colour code search its material in the parse scopes stack\n      if (colourCode.startsWith(\"0x2\")) {\n        // Special 'direct' material value (RGB colour)\n        var colour = colourCode.substring(3);\n        return this.parseColourMetaDirective(new LineParser(\"Direct_Color_\" + colour + \" CODE -1 VALUE #\" + colour + \" EDGE #\" + colour + \"\"));\n      }\n\n      for (var i = this.parseScopesStack.length - 1; i >= 0; i--) {\n        var material = this.parseScopesStack[i].lib[colourCode];\n\n        if (material) {\n          return material;\n        }\n      } // Material was not found\n\n\n      return null;\n    },\n    getParentParseScope: function () {\n      if (this.parseScopesStack.length > 1) {\n        return this.parseScopesStack[this.parseScopesStack.length - 2];\n      }\n\n      return null;\n    },\n    getCurrentParseScope: function () {\n      if (this.parseScopesStack.length > 0) {\n        return this.parseScopesStack[this.parseScopesStack.length - 1];\n      }\n\n      return null;\n    },\n    parseColourMetaDirective: function (lineParser) {\n      // Parses a colour definition and returns a THREE.Material or null if error\n      var code = null; // Triangle and line colours\n\n      var colour = 0xFF00FF;\n      var edgeColour = 0xFF00FF; // Transparency\n\n      var alpha = 1;\n      var isTransparent = false; // Self-illumination:\n\n      var luminance = 0;\n      var finishType = LDrawLoader.FINISH_TYPE_DEFAULT;\n      var canHaveEnvMap = true;\n      var edgeMaterial = null;\n      var name = lineParser.getToken();\n\n      if (!name) {\n        throw 'LDrawLoader: Material name was expected after \"!COLOUR tag' + lineParser.getLineNumberString() + \".\";\n      } // Parse tag tokens and their parameters\n\n\n      var token = null;\n\n      while (true) {\n        token = lineParser.getToken();\n\n        if (!token) {\n          break;\n        }\n\n        switch (token.toUpperCase()) {\n          case \"CODE\":\n            code = lineParser.getToken();\n            break;\n\n          case \"VALUE\":\n            colour = lineParser.getToken();\n\n            if (colour.startsWith('0x')) {\n              colour = '#' + colour.substring(2);\n            } else if (!colour.startsWith('#')) {\n              throw 'LDrawLoader: Invalid colour while parsing material' + lineParser.getLineNumberString() + \".\";\n            }\n\n            break;\n\n          case \"EDGE\":\n            edgeColour = lineParser.getToken();\n\n            if (edgeColour.startsWith('0x')) {\n              edgeColour = '#' + edgeColour.substring(2);\n            } else if (!edgeColour.startsWith('#')) {\n              // Try to see if edge colour is a colour code\n              edgeMaterial = this.getMaterial(edgeColour);\n\n              if (!edgeMaterial) {\n                throw 'LDrawLoader: Invalid edge colour while parsing material' + lineParser.getLineNumberString() + \".\";\n              } // Get the edge material for this triangle material\n\n\n              edgeMaterial = edgeMaterial.userData.edgeMaterial;\n            }\n\n            break;\n\n          case 'ALPHA':\n            alpha = parseInt(lineParser.getToken());\n\n            if (isNaN(alpha)) {\n              throw 'LDrawLoader: Invalid alpha value in material definition' + lineParser.getLineNumberString() + \".\";\n            }\n\n            alpha = Math.max(0, Math.min(1, alpha / 255));\n\n            if (alpha < 1) {\n              isTransparent = true;\n            }\n\n            break;\n\n          case 'LUMINANCE':\n            luminance = parseInt(lineParser.getToken());\n\n            if (isNaN(luminance)) {\n              throw 'LDrawLoader: Invalid luminance value in material definition' + LineParser.getLineNumberString() + \".\";\n            }\n\n            luminance = Math.max(0, Math.min(1, luminance / 255));\n            break;\n\n          case 'CHROME':\n            finishType = LDrawLoader.FINISH_TYPE_CHROME;\n            break;\n\n          case 'PEARLESCENT':\n            finishType = LDrawLoader.FINISH_TYPE_PEARLESCENT;\n            break;\n\n          case 'RUBBER':\n            finishType = LDrawLoader.FINISH_TYPE_RUBBER;\n            break;\n\n          case 'MATTE_METALLIC':\n            finishType = LDrawLoader.FINISH_TYPE_MATTE_METALLIC;\n            break;\n\n          case 'METAL':\n            finishType = LDrawLoader.FINISH_TYPE_METAL;\n            break;\n\n          case 'MATERIAL':\n            // Not implemented\n            lineParser.setToEnd();\n            break;\n\n          default:\n            throw 'LDrawLoader: Unknown token \"' + token + '\" while parsing material' + lineParser.getLineNumberString() + \".\";\n            break;\n        }\n      }\n\n      var material = null;\n\n      switch (finishType) {\n        case LDrawLoader.FINISH_TYPE_DEFAULT:\n          material = new THREE.MeshStandardMaterial({\n            color: colour,\n            roughness: 0.3,\n            envMapIntensity: 0.3,\n            metalness: 0\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_PEARLESCENT:\n          // Try to imitate pearlescency by setting the specular to the complementary of the color, and low shininess\n          var specular = new THREE.Color(colour);\n          var hsl = specular.getHSL({\n            h: 0,\n            s: 0,\n            l: 0\n          });\n          hsl.h = (hsl.h + 0.5) % 1;\n          hsl.l = Math.min(1, hsl.l + (1 - hsl.l) * 0.7);\n          specular.setHSL(hsl.h, hsl.s, hsl.l);\n          material = new THREE.MeshPhongMaterial({\n            color: colour,\n            specular: specular,\n            shininess: 10,\n            reflectivity: 0.3\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_CHROME:\n          // Mirror finish surface\n          material = new THREE.MeshStandardMaterial({\n            color: colour,\n            roughness: 0,\n            metalness: 1\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_RUBBER:\n          // Rubber finish\n          material = new THREE.MeshStandardMaterial({\n            color: colour,\n            roughness: 0.9,\n            metalness: 0\n          });\n          canHaveEnvMap = false;\n          break;\n\n        case LDrawLoader.FINISH_TYPE_MATTE_METALLIC:\n          // Brushed metal finish\n          material = new THREE.MeshStandardMaterial({\n            color: colour,\n            roughness: 0.8,\n            metalness: 0.4\n          });\n          break;\n\n        case LDrawLoader.FINISH_TYPE_METAL:\n          // Average metal finish\n          material = new THREE.MeshStandardMaterial({\n            color: colour,\n            roughness: 0.2,\n            metalness: 0.85\n          });\n          break;\n\n        default:\n          // Should not happen\n          break;\n      }\n\n      material.transparent = isTransparent;\n      material.premultipliedAlpha = true;\n      material.opacity = alpha;\n      material.depthWrite = !isTransparent;\n      material.polygonOffset = true;\n      material.polygonOffsetFactor = 1;\n      material.userData.canHaveEnvMap = canHaveEnvMap;\n\n      if (luminance !== 0) {\n        material.emissive.set(material.color).multiplyScalar(luminance);\n      }\n\n      if (!edgeMaterial) {\n        // This is the material used for edges\n        edgeMaterial = new THREE.LineBasicMaterial({\n          color: edgeColour,\n          transparent: isTransparent,\n          opacity: alpha,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.code = code;\n        edgeMaterial.name = name + \" - Edge\";\n        edgeMaterial.userData.canHaveEnvMap = false; // This is the material used for conditional edges\n\n        edgeMaterial.userData.conditionalEdgeMaterial = new THREE.ShaderMaterial({\n          vertexShader: conditionalLineVertShader,\n          fragmentShader: conditionalLineFragShader,\n          uniforms: {\n            diffuse: {\n              value: new THREE.Color(edgeColour)\n            },\n            opacity: {\n              value: alpha\n            }\n          },\n          transparent: isTransparent,\n          depthWrite: !isTransparent\n        });\n        edgeMaterial.userData.conditionalEdgeMaterial.userData.canHaveEnvMap = false;\n      }\n\n      material.userData.code = code;\n      material.name = name;\n      material.userData.edgeMaterial = edgeMaterial;\n      return material;\n    },\n    //\n    objectParse: function (text) {\n      // Retrieve data from the parent parse scope\n      var parentParseScope = this.getParentParseScope(); // Main colour codes passed to this subobject (or default codes 16 and 24 if it is the root object)\n\n      var mainColourCode = parentParseScope.mainColourCode;\n      var mainEdgeColourCode = parentParseScope.mainEdgeColourCode;\n      var currentParseScope = this.getCurrentParseScope(); // Parse result variables\n\n      var triangles;\n      var lineSegments;\n      var conditionalSegments;\n      var subobjects = [];\n      var category = null;\n      var keywords = null;\n\n      if (text.indexOf('\\r\\n') !== -1) {\n        // This is faster than String.split with regex that splits on both\n        text = text.replace(/\\r\\n/g, '\\n');\n      }\n\n      var lines = text.split('\\n');\n      var numLines = lines.length;\n      var lineIndex = 0;\n      var parsingEmbeddedFiles = false;\n      var currentEmbeddedFileName = null;\n      var currentEmbeddedText = null;\n      var bfcCertified = false;\n      var bfcCCW = true;\n      var bfcInverted = false;\n      var bfcCull = true;\n      var type = '';\n      var startingConstructionStep = false;\n      var scope = this;\n\n      function parseColourCode(lineParser, forEdge) {\n        // Parses next colour code and returns a THREE.Material\n        var colourCode = lineParser.getToken();\n\n        if (!forEdge && colourCode === '16') {\n          colourCode = mainColourCode;\n        }\n\n        if (forEdge && colourCode === '24') {\n          colourCode = mainEdgeColourCode;\n        }\n\n        var material = scope.getMaterial(colourCode);\n\n        if (!material) {\n          throw 'LDrawLoader: Unknown colour code \"' + colourCode + '\" is used' + lineParser.getLineNumberString() + ' but it was not defined previously.';\n        }\n\n        return material;\n      }\n\n      function parseVector(lp) {\n        var v = new THREE.Vector3(parseFloat(lp.getToken()), parseFloat(lp.getToken()), parseFloat(lp.getToken()));\n\n        if (!scope.separateObjects) {\n          v.applyMatrix4(currentParseScope.currentMatrix);\n        }\n\n        return v;\n      } // Parse all line commands\n\n\n      for (lineIndex = 0; lineIndex < numLines; lineIndex++) {\n        var line = lines[lineIndex];\n        if (line.length === 0) continue;\n\n        if (parsingEmbeddedFiles) {\n          if (line.startsWith('0 FILE ')) {\n            // Save previous embedded file in the cache\n            this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText; // New embedded text file\n\n            currentEmbeddedFileName = line.substring(7);\n            currentEmbeddedText = '';\n          } else {\n            currentEmbeddedText += line + '\\n';\n          }\n\n          continue;\n        }\n\n        var lp = new LineParser(line, lineIndex + 1);\n        lp.seekNonSpace();\n\n        if (lp.isAtTheEnd()) {\n          // Empty line\n          continue;\n        } // Parse the line type\n\n\n        var lineType = lp.getToken();\n\n        switch (lineType) {\n          // Line type 0: Comment or META\n          case '0':\n            // Parse meta directive\n            var meta = lp.getToken();\n\n            if (meta) {\n              switch (meta) {\n                case '!LDRAW_ORG':\n                  type = lp.getToken();\n                  currentParseScope.triangles = [];\n                  currentParseScope.lineSegments = [];\n                  currentParseScope.conditionalSegments = [];\n                  currentParseScope.type = type;\n                  var isRoot = !parentParseScope.isFromParse;\n\n                  if (isRoot || scope.separateObjects && !isPrimitiveType(type)) {\n                    currentParseScope.groupObject = new THREE.Group();\n                    currentParseScope.groupObject.userData.startingConstructionStep = currentParseScope.startingConstructionStep;\n                  } // If the scale of the object is negated then the triangle winding order\n                  // needs to be flipped.\n\n\n                  var matrix = currentParseScope.matrix;\n\n                  if (matrix.determinant() < 0 && (scope.separateObjects && isPrimitiveType(type) || !scope.separateObjects)) {\n                    currentParseScope.inverted = !currentParseScope.inverted;\n                  }\n\n                  triangles = currentParseScope.triangles;\n                  lineSegments = currentParseScope.lineSegments;\n                  conditionalSegments = currentParseScope.conditionalSegments;\n                  break;\n\n                case '!COLOUR':\n                  var material = this.parseColourMetaDirective(lp);\n\n                  if (material) {\n                    this.addMaterial(material);\n                  } else {\n                    console.warn('LDrawLoader: Error parsing material' + lp.getLineNumberString());\n                  }\n\n                  break;\n\n                case '!CATEGORY':\n                  category = lp.getToken();\n                  break;\n\n                case '!KEYWORDS':\n                  var newKeywords = lp.getRemainingString().split(',');\n\n                  if (newKeywords.length > 0) {\n                    if (!keywords) {\n                      keywords = [];\n                    }\n\n                    newKeywords.forEach(function (keyword) {\n                      keywords.push(keyword.trim());\n                    });\n                  }\n\n                  break;\n\n                case 'FILE':\n                  if (lineIndex > 0) {\n                    // Start embedded text files parsing\n                    parsingEmbeddedFiles = true;\n                    currentEmbeddedFileName = lp.getRemainingString();\n                    currentEmbeddedText = '';\n                    bfcCertified = false;\n                    bfcCCW = true;\n                  }\n\n                  break;\n\n                case 'BFC':\n                  // Changes to the backface culling state\n                  while (!lp.isAtTheEnd()) {\n                    var token = lp.getToken();\n\n                    switch (token) {\n                      case 'CERTIFY':\n                      case 'NOCERTIFY':\n                        bfcCertified = token === 'CERTIFY';\n                        bfcCCW = true;\n                        break;\n\n                      case 'CW':\n                      case 'CCW':\n                        bfcCCW = token === 'CCW';\n                        break;\n\n                      case 'INVERTNEXT':\n                        bfcInverted = true;\n                        break;\n\n                      case 'CLIP':\n                      case 'NOCLIP':\n                        bfcCull = token === 'CLIP';\n                        break;\n\n                      default:\n                        console.warn('THREE.LDrawLoader: BFC directive \"' + token + '\" is unknown.');\n                        break;\n                    }\n                  }\n\n                  break;\n\n                case 'STEP':\n                  startingConstructionStep = true;\n                  break;\n\n                default:\n                  // Other meta directives are not implemented\n                  break;\n              }\n            }\n\n            break;\n          // Line type 1: Sub-object file\n\n          case '1':\n            var material = parseColourCode(lp);\n            var posX = parseFloat(lp.getToken());\n            var posY = parseFloat(lp.getToken());\n            var posZ = parseFloat(lp.getToken());\n            var m0 = parseFloat(lp.getToken());\n            var m1 = parseFloat(lp.getToken());\n            var m2 = parseFloat(lp.getToken());\n            var m3 = parseFloat(lp.getToken());\n            var m4 = parseFloat(lp.getToken());\n            var m5 = parseFloat(lp.getToken());\n            var m6 = parseFloat(lp.getToken());\n            var m7 = parseFloat(lp.getToken());\n            var m8 = parseFloat(lp.getToken());\n            var matrix = new THREE.Matrix4().set(m0, m1, m2, posX, m3, m4, m5, posY, m6, m7, m8, posZ, 0, 0, 0, 1);\n            var fileName = lp.getRemainingString().trim().replace(/\\\\/g, \"/\");\n\n            if (scope.fileMap[fileName]) {\n              // Found the subobject path in the preloaded file path map\n              fileName = scope.fileMap[fileName];\n            } else {\n              // Standardized subfolders\n              if (fileName.startsWith('s/')) {\n                fileName = 'parts/' + fileName;\n              } else if (fileName.startsWith('48/')) {\n                fileName = 'p/' + fileName;\n              }\n            }\n\n            subobjects.push({\n              material: material,\n              matrix: matrix,\n              fileName: fileName,\n              originalFileName: fileName,\n              locationState: LDrawLoader.FILE_LOCATION_AS_IS,\n              url: null,\n              triedLowerCase: false,\n              inverted: bfcInverted !== currentParseScope.inverted,\n              startingConstructionStep: startingConstructionStep\n            });\n            bfcInverted = false;\n            break;\n          // Line type 2: Line segment\n\n          case '2':\n            var material = parseColourCode(lp, true);\n            var segment = {\n              material: material.userData.edgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp)\n            };\n            lineSegments.push(segment);\n            break;\n          // Line type 5: Conditional Line segment\n\n          case '5':\n            var material = parseColourCode(lp, true);\n            var segment = {\n              material: material.userData.edgeMaterial.userData.conditionalEdgeMaterial,\n              colourCode: material.userData.code,\n              v0: parseVector(lp),\n              v1: parseVector(lp),\n              c0: parseVector(lp),\n              c1: parseVector(lp)\n            };\n            conditionalSegments.push(segment);\n            break;\n          // Line type 3: Triangle\n\n          case '3':\n            var material = parseColourCode(lp);\n            var inverted = currentParseScope.inverted;\n            var ccw = bfcCCW !== inverted;\n            var doubleSided = !bfcCertified || !bfcCull;\n            var v0, v1, v2, faceNormal;\n\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n            } else {\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n\n            tempVec0.subVectors(v1, v0);\n            tempVec1.subVectors(v2, v1);\n            faceNormal = new THREE.Vector3().crossVectors(tempVec0, tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n\n            break;\n          // Line type 4: Quadrilateral\n\n          case '4':\n            var material = parseColourCode(lp);\n            var inverted = currentParseScope.inverted;\n            var ccw = bfcCCW !== inverted;\n            var doubleSided = !bfcCertified || !bfcCull;\n            var v0, v1, v2, v3, faceNormal;\n\n            if (ccw === true) {\n              v0 = parseVector(lp);\n              v1 = parseVector(lp);\n              v2 = parseVector(lp);\n              v3 = parseVector(lp);\n            } else {\n              v3 = parseVector(lp);\n              v2 = parseVector(lp);\n              v1 = parseVector(lp);\n              v0 = parseVector(lp);\n            }\n\n            tempVec0.subVectors(v1, v0);\n            tempVec1.subVectors(v2, v1);\n            faceNormal = new THREE.Vector3().crossVectors(tempVec0, tempVec1).normalize();\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v1,\n              v2: v2,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n            triangles.push({\n              material: material,\n              colourCode: material.userData.code,\n              v0: v0,\n              v1: v2,\n              v2: v3,\n              faceNormal: faceNormal,\n              n0: null,\n              n1: null,\n              n2: null\n            });\n\n            if (doubleSided === true) {\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v2,\n                v2: v1,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n              triangles.push({\n                material: material,\n                colourCode: material.userData.code,\n                v0: v0,\n                v1: v3,\n                v2: v2,\n                faceNormal: faceNormal,\n                n0: null,\n                n1: null,\n                n2: null\n              });\n            }\n\n            break;\n\n          default:\n            throw 'LDrawLoader: Unknown line type \"' + lineType + '\"' + lp.getLineNumberString() + '.';\n            break;\n        }\n      }\n\n      if (parsingEmbeddedFiles) {\n        this.subobjectCache[currentEmbeddedFileName.toLowerCase()] = currentEmbeddedText;\n      }\n\n      currentParseScope.category = category;\n      currentParseScope.keywords = keywords;\n      currentParseScope.subobjects = subobjects;\n      currentParseScope.numSubobjects = subobjects.length;\n      currentParseScope.subobjectIndex = 0;\n    },\n    computeConstructionSteps: function (model) {\n      // Sets userdata.constructionStep number in Group objects and userData.numConstructionSteps number in the root Group object.\n      var stepNumber = 0;\n      model.traverse(c => {\n        if (c.isGroup) {\n          if (c.userData.startingConstructionStep) {\n            stepNumber++;\n          }\n\n          c.userData.constructionStep = stepNumber;\n        }\n      });\n      model.userData.numConstructionSteps = stepNumber + 1;\n    },\n    processObject: function (text, onProcessed, subobject, url) {\n      var scope = this;\n      var parseScope = scope.newParseScopeLevel();\n      parseScope.url = url;\n      var parentParseScope = scope.getParentParseScope(); // Set current matrix\n\n      if (subobject) {\n        parseScope.currentMatrix.multiplyMatrices(parentParseScope.currentMatrix, subobject.matrix);\n        parseScope.matrix.copy(subobject.matrix);\n        parseScope.inverted = subobject.inverted;\n        parseScope.startingConstructionStep = subobject.startingConstructionStep;\n      } // Add to cache\n\n\n      var currentFileName = parentParseScope.currentFileName;\n\n      if (currentFileName !== null) {\n        currentFileName = parentParseScope.currentFileName.toLowerCase();\n      }\n\n      if (scope.subobjectCache[currentFileName] === undefined) {\n        scope.subobjectCache[currentFileName] = text;\n      } // Parse the object (returns a THREE.Group)\n\n\n      scope.objectParse(text);\n      var finishedCount = 0;\n      onSubobjectFinish();\n\n      function onSubobjectFinish() {\n        finishedCount++;\n\n        if (finishedCount === parseScope.subobjects.length + 1) {\n          finalizeObject();\n        } else {\n          // Once the previous subobject has finished we can start processing the next one in the list.\n          // The subobject processing shares scope in processing so it's important that they be loaded serially\n          // to avoid race conditions.\n          // Promise.resolve is used as an approach to asynchronously schedule a task _before_ this frame ends to\n          // avoid stack overflow exceptions when loading many subobjects from the cache. RequestAnimationFrame\n          // will work but causes the load to happen after the next frame which causes the load to take significantly longer.\n          var subobject = parseScope.subobjects[parseScope.subobjectIndex];\n          Promise.resolve().then(function () {\n            loadSubobject(subobject);\n          });\n          parseScope.subobjectIndex++;\n        }\n      }\n\n      function finalizeObject() {\n        if (scope.smoothNormals && parseScope.type === 'Part') {\n          smoothNormals(parseScope.triangles, parseScope.lineSegments);\n        }\n\n        var isRoot = !parentParseScope.isFromParse;\n\n        if (scope.separateObjects && !isPrimitiveType(parseScope.type) || isRoot) {\n          const objGroup = parseScope.groupObject;\n\n          if (parseScope.triangles.length > 0) {\n            objGroup.add(createObject(parseScope.triangles, 3));\n          }\n\n          if (parseScope.lineSegments.length > 0) {\n            objGroup.add(createObject(parseScope.lineSegments, 2));\n          }\n\n          if (parseScope.conditionalSegments.length > 0) {\n            objGroup.add(createObject(parseScope.conditionalSegments, 2, true));\n          }\n\n          if (parentParseScope.groupObject) {\n            objGroup.name = parseScope.fileName;\n            objGroup.userData.category = parseScope.category;\n            objGroup.userData.keywords = parseScope.keywords;\n            parseScope.matrix.decompose(objGroup.position, objGroup.quaternion, objGroup.scale);\n            parentParseScope.groupObject.add(objGroup);\n          }\n        } else {\n          var separateObjects = scope.separateObjects;\n          var parentLineSegments = parentParseScope.lineSegments;\n          var parentConditionalSegments = parentParseScope.conditionalSegments;\n          var parentTriangles = parentParseScope.triangles;\n          var lineSegments = parseScope.lineSegments;\n          var conditionalSegments = parseScope.conditionalSegments;\n          var triangles = parseScope.triangles;\n\n          for (var i = 0, l = lineSegments.length; i < l; i++) {\n            var ls = lineSegments[i];\n\n            if (separateObjects) {\n              ls.v0.applyMatrix4(parseScope.matrix);\n              ls.v1.applyMatrix4(parseScope.matrix);\n            }\n\n            parentLineSegments.push(ls);\n          }\n\n          for (var i = 0, l = conditionalSegments.length; i < l; i++) {\n            var os = conditionalSegments[i];\n\n            if (separateObjects) {\n              os.v0.applyMatrix4(parseScope.matrix);\n              os.v1.applyMatrix4(parseScope.matrix);\n              os.c0.applyMatrix4(parseScope.matrix);\n              os.c1.applyMatrix4(parseScope.matrix);\n            }\n\n            parentConditionalSegments.push(os);\n          }\n\n          for (var i = 0, l = triangles.length; i < l; i++) {\n            var tri = triangles[i];\n\n            if (separateObjects) {\n              tri.v0 = tri.v0.clone().applyMatrix4(parseScope.matrix);\n              tri.v1 = tri.v1.clone().applyMatrix4(parseScope.matrix);\n              tri.v2 = tri.v2.clone().applyMatrix4(parseScope.matrix);\n              tempVec0.subVectors(tri.v1, tri.v0);\n              tempVec1.subVectors(tri.v2, tri.v1);\n              tri.faceNormal.crossVectors(tempVec0, tempVec1).normalize();\n            }\n\n            parentTriangles.push(tri);\n          }\n        }\n\n        scope.removeScopeLevel(); // If it is root object, compute construction steps\n\n        if (!parentParseScope.isFromParse) {\n          scope.computeConstructionSteps(parseScope.groupObject);\n        }\n\n        if (onProcessed) {\n          onProcessed(parseScope.groupObject);\n        }\n      }\n\n      function loadSubobject(subobject) {\n        parseScope.mainColourCode = subobject.material.userData.code;\n        parseScope.mainEdgeColourCode = subobject.material.userData.edgeMaterial.userData.code;\n        parseScope.currentFileName = subobject.originalFileName; // If subobject was cached previously, use the cached one\n\n        var cached = scope.subobjectCache[subobject.originalFileName.toLowerCase()];\n\n        if (cached) {\n          scope.processObject(cached, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n          return;\n        } // Adjust file name to locate the subobject file path in standard locations (always under directory scope.path)\n        // Update also subobject.locationState for the next try if this load fails.\n\n\n        var subobjectURL = subobject.fileName;\n        var newLocationState = LDrawLoader.FILE_LOCATION_NOT_FOUND;\n\n        switch (subobject.locationState) {\n          case LDrawLoader.FILE_LOCATION_AS_IS:\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_PARTS:\n            subobjectURL = 'parts/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_P:\n            subobjectURL = 'p/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_MODELS:\n            subobjectURL = 'models/' + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_RELATIVE:\n            subobjectURL = url.substring(0, url.lastIndexOf(\"/\") + 1) + subobjectURL;\n            newLocationState = subobject.locationState + 1;\n            break;\n\n          case LDrawLoader.FILE_LOCATION_TRY_ABSOLUTE:\n            if (subobject.triedLowerCase) {\n              // Try absolute path\n              newLocationState = LDrawLoader.FILE_LOCATION_NOT_FOUND;\n            } else {\n              // Next attempt is lower case\n              subobject.fileName = subobject.fileName.toLowerCase();\n              subobjectURL = subobject.fileName;\n              subobject.triedLowerCase = true;\n              newLocationState = LDrawLoader.FILE_LOCATION_AS_IS;\n            }\n\n            break;\n\n          case LDrawLoader.FILE_LOCATION_NOT_FOUND:\n            // All location possibilities have been tried, give up loading this object\n            console.warn('LDrawLoader: Subobject \"' + subobject.originalFileName + '\" could not be found.');\n            return;\n        }\n\n        subobject.locationState = newLocationState;\n        subobject.url = subobjectURL; // Load the subobject\n        // Use another file loader here so we can keep track of the subobject information\n        // and use it when processing the next model.\n\n        var fileLoader = new THREE.FileLoader(scope.manager);\n        fileLoader.setPath(scope.path);\n        fileLoader.setRequestHeader(scope.requestHeader);\n        fileLoader.setWithCredentials(scope.withCredentials);\n        fileLoader.load(subobjectURL, function (text) {\n          scope.processObject(text, function (subobjectGroup) {\n            onSubobjectLoaded(subobjectGroup, subobject);\n            onSubobjectFinish();\n          }, subobject, url);\n        }, undefined, function (err) {\n          onSubobjectError(err, subobject);\n        }, subobject);\n      }\n\n      function onSubobjectLoaded(subobjectGroup, subobject) {\n        if (subobjectGroup === null) {\n          // Try to reload\n          loadSubobject(subobject);\n          return;\n        }\n\n        scope.fileMap[subobject.originalFileName] = subobject.url;\n      }\n\n      function onSubobjectError(err, subobject) {\n        // Retry download from a different default possible location\n        loadSubobject(subobject);\n      }\n    }\n  });\n  return LDrawLoader;\n}();\n\n//# sourceURL=webpack:///./LDrawLoader.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* global AFRAME */\n// import local version of LDrawLoader for now\n__webpack_require__(/*! ./LDrawLoader.js */ \"./LDrawLoader.js\");\n\nif (typeof AFRAME === 'undefined') {\n  throw new Error('Component attempted to register before AFRAME was available.');\n}\n/**\n * Bricks component for A-Frame.\n */\n\n\nAFRAME.registerComponent('bricks', {\n  schema: {\n    src: {\n      type: \"model\"\n    },\n    steps: {\n      type: \"int\"\n    }\n  },\n  init: function () {\n    this.model = null;\n    this.ldrawLoader = new THREE.LDrawLoader();\n    this.isBuggy = AFRAME.version !== \"1.0.4-blocks-mod\";\n  },\n  update: function (oldData) {\n    // load new model if the source has changed\n    if (this.data.src !== oldData.src) {\n      this.resetMesh();\n      this.loadModel(this.data.src, this.data.steps);\n    }\n\n    if (this.data.steps !== oldData.steps && this.model) {\n      this.setStep(this.data.steps);\n    }\n  },\n  remove: function () {\n    if (!this.model) {\n      return;\n    }\n\n    this.resetMesh();\n  },\n  resetMesh: function () {\n    this.el.removeObject3D(\"mesh\");\n  },\n  pause: function () {\n    // hide the model in the aframe inspector\n    // since a Three.js bug in Mesh.intersect results in an infinte loop\n    if (this.isBuggy) {\n      console.log(\"Three.js has a bug that prevents previews of Brick models.\");\n      console.log(\"Using Edges-only preview in the Inspector\");\n\n      if (this.data.steps) {\n        // hide faces of all bricks\n        console.log(\"CHILDREN\", this.model.children);\n        this.model.children.forEach(brick => this.hide(brick));\n      } else {\n        // hide faces of the model\n        this.show(this.model);\n      }\n    }\n  },\n  play: function () {\n    // show the model again\n    if (this.isBuggy) {\n      if (this.data.steps) {\n        this.model.children.forEach(brick => this.show(brick));\n      } else {\n        this.show(this.model);\n      }\n    }\n  },\n  show: function (obj) {\n    // show the brick surface\n    obj.children[0].visible = true;\n  },\n  hide: function (obj) {\n    // hide the brick surface\n    obj.children[0].visible = false;\n  },\n  loadModel: function (url, steps) {\n    let el = this.el;\n    let ldrawLoader = this.ldrawLoader; // separate objects into individual building steps\n\n    ldrawLoader.separateObjects = true;\n    ldrawLoader.load(url, model => {\n      console.log(\"Construction Steps\", model.userData.numConstructionSteps);\n      console.log(model);\n      this.model = model;\n      model.scale.y = -1;\n\n      if (steps) {\n        this.setStep(steps);\n      }\n\n      el.setObject3D('mesh', model);\n      el.emit(\"model-loaded\", {\n        format: \"ldraw\",\n        model: model\n      });\n    });\n  },\n  setStep: function (step) {\n    this.model.traverse(c => {\n      if (c.isGroup) {\n        c.visible = c.userData.constructionStep <= step;\n      }\n    });\n  }\n}); // register block\n\nlet meshMixin = AFRAME.primitives.getMeshMixin();\nAFRAME.registerPrimitive(\"a-bricks\", AFRAME.utils.extendDeep({}, meshMixin, {\n  defaultComponents: {\n    \"bricks\": {}\n  },\n  mappings: {\n    src: \"bricks.src\",\n    steps: \"bricks.steps\"\n  }\n}));\n\n//# sourceURL=webpack:///./index.js?");

/***/ })

/******/ });
});